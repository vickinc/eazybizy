import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { CacheService, CacheKeys, CacheTTL } from '@/lib/redis'
import { LightResponseUtils } from '@/lib/compression'
import { authenticateRequest } from '@/lib/api-auth'
import { AnniversaryApiService } from '@/services/api/anniversaryApiService'

interface DashboardSummary {
  stats: {
    totalCompanies: number
    activeCompaniesCount: number
    passiveCompaniesCount: number
    upcomingEventsCount: number
    activeNotesCount: number
    activeBusinessCardsCount: number
    archivedBusinessCardsCount: number
  }
  recentActiveCompanies: Array<{
    id: number
    legalName: string
    tradingName: string
    logo: string
    status: string
    createdAt: Date
  }>
  nextUpcomingEvents: Array<{
    id: string
    title: string
    date: Date
    time: string
    type: string
    priority: string
    company: string
    companyId: number
    isSystemGenerated?: boolean
  }>
  activeNotes: Array<{
    id: string
    title: string
    content: string
    priority: string
    isCompleted: boolean
    createdAt: Date
    companyId: number
  }>
  cached: boolean
  responseTime: number
}

export async function GET(request: NextRequest) {
  const startTime = Date.now()
  console.log('ðŸ”¥ DASHBOARD API CALLED - Starting fresh data fetch')

  try {
    // Authenticate the user to filter deleted events properly
    const { user: currentUser, error } = await authenticateRequest();
    if (error) return error;
    if (!currentUser) return LightResponseUtils.json({ error: 'Unauthorized' }, { status: 401 });

    // Get user from database
    const user = await prisma.user.findUnique({
      where: { email: currentUser.email },
      select: { id: true }
    });

    if (!user) {
      return LightResponseUtils.json({ error: 'User not found' }, { status: 404 });
    }
    
    // Check cache first (user-specific cache)
    const cacheKey = `dashboard:summary:v2:${user.id}` // User-specific cache key
    
    // Clear cache for testing
    await CacheService.del(cacheKey)
    await CacheService.del('dashboard:summary:v1') // Clear old cache too
    
    const cachedData = await CacheService.get<DashboardSummary>(cacheKey)
    
    if (cachedData) {
      return LightResponseUtils.json({
        ...cachedData,
        cached: true,
        responseTime: Date.now() - startTime
      })
    }

    // Fetch all data in parallel with optimized queries
    const [
      companiesStats,
      recentActiveCompanies,
      nextUpcomingEvents,
      activeNotes,
      businessCardsStats
    ] = await Promise.all([
      // Company stats
      prisma.company.groupBy({
        by: ['status'],
        _count: { id: true },
        where: { status: { in: ['Active', 'Passive'] } }
      }),
      
      // Recent active companies (last 3, essential fields only)
      prisma.company.findMany({
        where: { status: 'Active' },
        select: {
          id: true,
          legalName: true,
          tradingName: true,
          logo: true,
          status: true,
          createdAt: true,
          updatedAt: true
        },
        orderBy: { updatedAt: 'desc' },
        take: 3
      }),
      
      // Next upcoming events (next 3, essential fields only)
      // Include ALL events: user-created AND auto-generated anniversaries
      prisma.calendarEvent.findMany({
        where: {
          date: { 
            gte: new Date(),
            lte: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days from now
          }
        },
        select: {
          id: true,
          title: true,
          date: true,
          time: true,
          type: true,
          priority: true,
          company: true,
          companyId: true,
          isAutoGenerated: true
        },
        orderBy: [
          { date: 'asc' },
          { time: 'asc' }
        ],
        take: 3
      }),
      
      // Active notes (last 2, essential fields only)
      prisma.note.findMany({
        where: { isCompleted: false },
        select: {
          id: true,
          title: true,
          content: true,
          priority: true,
          isCompleted: true,
          createdAt: true,
          companyId: true
        },
        orderBy: { createdAt: 'desc' },
        take: 2
      }),
      
      // Business cards stats
      prisma.businessCard.groupBy({
        by: ['isArchived'],
        _count: { id: true }
      })
    ])

    // Process stats
    const totalCompanies = companiesStats.reduce((sum, stat) => sum + stat._count.id, 0)
    const activeCompaniesCount = companiesStats.find(s => s.status === 'Active')?._count.id || 0
    const passiveCompaniesCount = companiesStats.find(s => s.status === 'Passive')?._count.id || 0
    
    const activeBusinessCardsCount = businessCardsStats.find(s => !s.isArchived)?._count.id || 0
    const archivedBusinessCardsCount = businessCardsStats.find(s => s.isArchived)?._count.id || 0

    // Get upcoming events count for next 30 days
    const thirtyDaysFromNow = new Date()
    thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30)
    
    const upcomingEventsCount = await prisma.calendarEvent.count({
      where: {
        date: {
          gte: new Date(),
          lte: thirtyDaysFromNow
        }
      }
    })

    const activeNotesCount = await prisma.note.count({
      where: { isCompleted: false }
    })

    // Fetch anniversary events using the shared Calendar API service
    let anniversaryEvents: any[] = [];
    try {
      const anniversaryResult = await AnniversaryApiService.getUpcomingAnniversaryEvents({
        userId: user.id,
        days: 60
      });
      
      anniversaryEvents = anniversaryResult.events || [];
      console.log('Dashboard: Fetched anniversary events from Calendar API service:', anniversaryEvents.length);
    } catch (error) {
      console.error('Dashboard: Error fetching anniversary events from Calendar API service:', error);
    }

    // Create a map to track events and avoid duplicates
    const eventMap = new Map<string, any>();
    
    // Add database events first (normalize casing)
    nextUpcomingEvents.forEach(event => {
      console.log('Dashboard: Processing database event:', {
        id: event.id,
        title: event.title,
        originalType: event.type,
        normalizedType: event.type?.toLowerCase(),
        originalPriority: event.priority,
        normalizedPriority: event.priority?.toLowerCase()
      });
      eventMap.set(event.id, {
        ...event,
        type: event.type?.toLowerCase() || 'other',
        priority: event.priority?.toLowerCase() || 'medium',
        isSystemGenerated: false,
        company: event.company || ''
      });
    });
    
    // Add anniversary events from Calendar API service (only if they don't already exist in database)
    anniversaryEvents.forEach(event => {
      if (!eventMap.has(event.id)) {
        console.log('Dashboard: Processing anniversary event from Calendar API service:', {
          id: event.id,
          title: event.title,
          type: event.type,
          priority: event.priority,
          company: event.company
        });
        eventMap.set(event.id, {
          id: event.id,
          title: event.title,
          date: event.date,
          time: event.time,
          type: event.type?.toLowerCase() || 'anniversary',
          priority: event.priority?.toLowerCase() || 'medium',
          company: event.company || '',
          companyId: event.companyId,
          isSystemGenerated: true
        });
      }
    });
    
    // Convert map to array
    const combinedEvents = Array.from(eventMap.values());

    // Sort by date and take top 3
    const sortedEvents = combinedEvents
      .sort((a, b) => {
        const dateA = new Date(a.date)
        const dateB = new Date(b.date)
        if (dateA.getTime() === dateB.getTime()) {
          return a.time.localeCompare(b.time)
        }
        return dateA.getTime() - dateB.getTime()
      })
      .slice(0, 3)
      
    console.log('Dashboard: Final sorted events:', sortedEvents.map(e => ({
      id: e.id,
      title: e.title,
      type: e.type,
      priority: e.priority,
      isSystemGenerated: e.isSystemGenerated
    })));

    const dashboardData: DashboardSummary = {
      stats: {
        totalCompanies,
        activeCompaniesCount,
        passiveCompaniesCount,
        upcomingEventsCount,
        activeNotesCount,
        activeBusinessCardsCount,
        archivedBusinessCardsCount
      },
      recentActiveCompanies,
      nextUpcomingEvents: sortedEvents,
      activeNotes,
      cached: false,
      responseTime: Date.now() - startTime
    }

    // Cache the results for 5 minutes
    await CacheService.set(cacheKey, dashboardData, 300)

    return LightResponseUtils.json(dashboardData)

  } catch (error) {
    console.error('Error fetching dashboard summary:', error)
    const totalTime = Date.now() - startTime
    return LightResponseUtils.json(
      { 
        error: 'Failed to fetch dashboard summary',
        responseTime: totalTime 
      },
      { status: 500 }
    )
  }
}