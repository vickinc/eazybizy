import { NextRequest, NextResponse } from 'next/server';
import { AnniversaryEventService } from '@/services/business/anniversaryEventService';

// POST /api/calendar/anniversary-events/test-rollover - Test anniversary rollover functionality
export async function POST(request: NextRequest) {
  try {
    const body = await request.json().catch(() => ({}));
    const { 
      companyId,
      force = false
    } = body;

    console.log(`ðŸ§ª Testing anniversary rollover${companyId ? ` for company ${companyId}` : ' for all companies'}${force ? ' (forced)' : ''}`);

    // Use force rollover to bypass cache for testing
    const result = force 
      ? await AnniversaryEventService.forceAnniversaryRollover(companyId)
      : await AnniversaryEventService.checkAndGenerateNextAnniversaries(companyId);

    const response = {
      success: result.success,
      message: result.message,
      stats: result.stats,
      testMode: true,
      timestamp: new Date().toISOString()
    };

    console.log('ðŸ§ª Test rollover result:', response);

    return NextResponse.json(response);
  } catch (error) {
    console.error('ðŸ§ª Test rollover failed:', error);
    return NextResponse.json(
      { 
        error: 'Test rollover failed',
        message: error instanceof Error ? error.message : 'Unknown error',
        testMode: true,
        timestamp: new Date().toISOString()
      },
      { status: 500 }
    );
  }
}

// GET /api/calendar/anniversary-events/test-rollover - Get rollover test status
export async function GET() {
  try {
    const { prisma } = require('@/lib/prisma');
    
    // Get summary of anniversary events
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const allEvents = await prisma.calendarEvent.findMany({
      where: {
        isAutoGenerated: true,
        type: 'ANNIVERSARY'
      },
      include: {
        companyRecord: {
          select: {
            tradingName: true,
            registrationDate: true
          }
        }
      },
      orderBy: [
        { companyId: 'asc' },
        { date: 'asc' }
      ]
    });

    const passedEvents = allEvents.filter(e => e.date < today);
    const upcomingEvents = allEvents.filter(e => e.date >= today);

    // Group by company to identify companies needing rollover
    const eventsByCompany = {};
    allEvents.forEach(event => {
      const companyId = event.companyId;
      if (!eventsByCompany[companyId]) {
        eventsByCompany[companyId] = {
          companyName: event.companyRecord?.tradingName || `Company ${companyId}`,
          events: [],
          passed: 0,
          upcoming: 0
        };
      }
      eventsByCompany[companyId].events.push(event);
      if (event.date < today) {
        eventsByCompany[companyId].passed++;
      } else {
        eventsByCompany[companyId].upcoming++;
      }
    });

    const companiesNeedingRollover = Object.entries(eventsByCompany)
      .filter(([_, data]) => data.passed > 0 && data.upcoming === 0)
      .map(([companyId, data]) => ({
        companyId: parseInt(companyId),
        companyName: data.companyName,
        passedEvents: data.passed
      }));

    const response = {
      success: true,
      summary: {
        totalEvents: allEvents.length,
        passedEvents: passedEvents.length,
        upcomingEvents: upcomingEvents.length,
        companies: Object.keys(eventsByCompany).length,
        companiesNeedingRollover: companiesNeedingRollover.length
      },
      companiesNeedingRollover,
      testMode: true,
      timestamp: new Date().toISOString()
    };

    return NextResponse.json(response);
  } catch (error) {
    console.error('Failed to get rollover test status:', error);
    return NextResponse.json(
      { 
        error: 'Failed to get test status',
        message: error instanceof Error ? error.message : 'Unknown error',
        testMode: true,
        timestamp: new Date().toISOString()
      },
      { status: 500 }
    );
  }
}