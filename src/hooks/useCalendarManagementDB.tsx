import { useState, useCallback, useEffect } from 'react';
import { 
  useQuery, 
  useInfiniteQuery, 
  useMutation, 
  useQueryClient 
} from '@tanstack/react-query';
import { CalendarEvent, Note, CalendarEventFormData } from '@/types/calendar.types';
import { Company } from '@/types';
import { 
  CalendarService, 
  CalendarEventFilters,
  CalendarEventCreateRequest,
  CalendarEventUpdateRequest,
  CalendarStatisticsResponse
} from '@/services/api/calendarService';
import { CalendarValidationService } from '@/services/business/calendarValidationService';
import { CalendarBusinessService } from '@/services/business/calendarBusinessService';
import { CompanyAnniversaryService } from '@/services/business/companyAnniversaryService';
// Note: AutoGeneratedEventSyncService is server-side only, we'll use API calls instead
import { useAuth } from '@/hooks/useAuth';

export interface CalendarManagementDBHook {
  // Data
  events: CalendarEvent[];
  notes: Note[];
  filteredEvents: CalendarEvent[];
  statistics: CalendarStatisticsResponse | undefined;
  
  // UI State
  selectedDate: Date | undefined;
  currentMonth: Date;
  isDialogOpen: boolean;
  editingEvent: CalendarEvent | null;
  isCalendarWidgetExpanded: boolean;
  isMobileCalendarOpen: boolean;
  
  // Form State
  formData: CalendarEventFormData;
  
  // Loading & Error States
  isLoading: boolean;
  isError: boolean;
  error: Error | null;
  isMutating: boolean;
  
  // Infinite Query States
  hasNextPage: boolean;
  isFetchingNextPage: boolean;
  fetchNextPage: () => void;
  
  // Actions
  setSelectedDate: (date: Date | undefined) => void;
  setCurrentMonth: (date: Date) => void;
  handleAddEvent: () => Promise<void>;
  handleEditEvent: (event: CalendarEvent) => void;
  handleUpdateEvent: () => Promise<void>;
  handleDeleteEvent: (eventId: string) => Promise<void>;
  resetDialog: () => void;
  openDialog: () => void;
  closeDialog: () => void;
  toggleCalendarWidget: () => void;
  toggleMobileCalendar: (open?: boolean) => void;
  
  // Form Actions
  updateFormField: (field: keyof CalendarEventFormData, value: string | Date | string[]) => void;
  
  // Filter Actions
  setFilters: (filters: CalendarEventFilters) => void;
  resetFilters: () => void;
  
  // Utility Functions
  getEventsForDate: (date: Date) => CalendarEvent[];
  getTodaysEvents: () => CalendarEvent[];
  getUpcomingEvents: () => CalendarEvent[];
  getThisWeekEvents: () => CalendarEvent[];
  getNotesForEvent: (eventId: string) => Note[];
  getPriorityColor: (priority: string) => string;
  formatDate: (date: Date) => string;
  formatDateForInput: (date: Date) => string;
  parseDateFromInput: (dateString: string) => Date;
  
  // Data Refresh
  refetch: () => void;
  invalidateCache: () => void;
}

const initialFormData: CalendarEventFormData = {
  title: '',
  description: '',
  date: new Date(),
  time: '09:00',
  type: 'meeting',
  priority: 'medium',
  company: '',
  participants: [],
  eventScope: 'personal',
  syncEnabled: true,
  targetCalendarId: 'primary'
};

// Generate smart form data based on company context
const getSmartFormData = (selectedCompany: string | number, companies: Company[]): CalendarEventFormData => {
  const isCompanyFiltered = selectedCompany !== 'all';
  const selectedCompanyObj = isCompanyFiltered ? companies.find(c => c.id === selectedCompany) : null;
  
  return {
    ...initialFormData,
    eventScope: isCompanyFiltered ? 'company' : 'personal',
    company: selectedCompanyObj?.tradingName || '',
    syncEnabled: true,
    targetCalendarId: 'primary'
  };
};

const initialFilters: CalendarEventFilters = {
  companyId: 'all',
  type: 'all',
  priority: 'all',
  search: '',
  dateFrom: '',
  dateTo: ''
};

export const useCalendarManagementDB = (
  selectedCompany: string | number,
  companies: Company[]
): CalendarManagementDBHook => {
  const queryClient = useQueryClient();
  const calendarService = new CalendarService();
  const { user } = useAuth();
  
  // UI State
  const [selectedDate, setSelectedDate] = useState<Date | undefined>(new Date());
  const [currentMonth, setCurrentMonth] = useState<Date>(new Date());
  const [isDialogOpen, setIsDialogOpen] = useState<boolean>(false);
  const [editingEvent, setEditingEvent] = useState<CalendarEvent | null>(null);
  const [isCalendarWidgetExpanded, setIsCalendarWidgetExpanded] = useState<boolean>(true);
  const [isMobileCalendarOpen, setIsMobileCalendarOpen] = useState<boolean>(false);
  const [formData, setFormData] = useState<CalendarEventFormData>(initialFormData);
  const [filters, setFiltersState] = useState<CalendarEventFilters>(initialFilters);
  

  // Initialize form data with smart defaults when company context changes
  useEffect(() => {
    if (!editingEvent && !isDialogOpen) {
      setFormData(getSmartFormData(selectedCompany, companies));
    }
  }, [selectedCompany, companies, editingEvent, isDialogOpen]);

  // Query Keys
  const eventsQueryKey = ['calendar', 'events', selectedCompany, filters];
  const notesQueryKey = ['calendar', 'notes', selectedCompany];
  const statisticsQueryKey = ['calendar', 'statistics', selectedCompany];

  // Events Query with Infinite Scroll
  const {
    data: eventsData,
    isLoading,
    isError,
    error,
    hasNextPage,
    isFetchingNextPage,
    fetchNextPage,
    refetch: refetchEvents
  } = useInfiniteQuery({
    queryKey: eventsQueryKey,
    queryFn: ({ pageParam }) => calendarService.getEventsWithCursor(
      pageParam,
      20,
      'desc',
      {
        ...filters,
        companyId: selectedCompany !== 'all' ? selectedCompany?.toString() : undefined
      }
    ),
    getNextPageParam: (lastPage) => lastPage.pagination.nextCursor,
    initialPageParam: undefined as string | undefined,
    staleTime: 30000, // 30 seconds
    gcTime: 300000 // 5 minutes
  });

  // Notes Query
  const { data: notesData } = useQuery({
    queryKey: notesQueryKey,
    queryFn: () => calendarService.getNotes(1, 1000, {
      companyId: selectedCompany !== 'all' ? selectedCompany?.toString() : undefined
    }),
    staleTime: 60000, // 1 minute
    gcTime: 300000 // 5 minutes
  });

  // Statistics Query
  const { data: statistics } = useQuery({
    queryKey: statisticsQueryKey,
    queryFn: () => calendarService.getStatistics(selectedCompany !== 'all' ? selectedCompany?.toString() : undefined),
    staleTime: 300000, // 5 minutes
    gcTime: 600000 // 10 minutes
  });

  // Mutations
  const createEventMutation = useMutation({
    mutationFn: (eventData: CalendarEventCreateRequest) => 
      calendarService.createEvent(eventData),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['calendar'] });
      // Optionally invalidate statistics cache (don't throw if it fails)
      calendarService.invalidateStatistics().catch(err => 
        console.warn('Failed to invalidate statistics cache:', err.message)
      );
    },
    onError: (error: unknown) => {
      console.error('Create event failed:', error);
    }
  });

  const updateEventMutation = useMutation({
    mutationFn: ({ id, data }: { id: string; data: CalendarEventUpdateRequest }) => 
      calendarService.updateEvent(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['calendar'] });
      // Optionally invalidate statistics cache (don't throw if it fails)
      calendarService.invalidateStatistics().catch(err => 
        console.warn('Failed to invalidate statistics cache:', err.message)
      );
    },
    onError: (error: unknown) => {
      console.error('Update event failed:', error);
    }
  });

  const deleteEventMutation = useMutation({
    mutationFn: (id: string) => calendarService.deleteEvent(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['calendar'] });
      // Optionally invalidate statistics cache (don't throw if it fails)
      calendarService.invalidateStatistics().catch(err => 
        console.warn('Failed to invalidate statistics cache:', err.message)
      );
    },
    onError: (error: unknown) => {
      console.error('Delete event failed:', error);
      // Don't throw - let the UI handle this gracefully
    }
  });

  // Extract events from infinite query data
  const databaseEvents = eventsData?.pages.flatMap(page => page.events) || [];
  const notes = notesData?.notes || [];

  // Generate anniversary events for 1 year ahead
  const currentDate = new Date();
  const startDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
  const endDate = new Date(currentDate.getFullYear() + 1, currentDate.getMonth(), currentDate.getDate()); // 1 year from today
  
  // Find anniversary events that have been overridden by database events
  const overriddenAnniversaryIds = new Set<string>();
  const [deletedAnniversaryIds, setDeletedAnniversaryIds] = useState<Set<string>>(new Set());
  
  // Get deleted anniversary events from the API
  useEffect(() => {
    const loadDeletedAnniversaryEvents = async () => {
      if (user?.id) {
        try {
          const response = await fetch('/api/calendar/auto-generated/deleted');
          if (response.ok) {
            const { deletedIds } = await response.json();
            setDeletedAnniversaryIds(new Set(deletedIds));
          }
        } catch (error) {
          console.error('Failed to load deleted anniversary events:', error);
        }
      }
    };
    loadDeletedAnniversaryEvents();
  }, [user?.id]);
  
  databaseEvents.forEach(event => {
    const descriptionToCheck = event.rawDescription || event.description;
    if (descriptionToCheck) {
      // Check for anniversary override markers in description
      const overrideMatch = descriptionToCheck.match(/\[ANNIVERSARY_OVERRIDE:([^\]]+)\]/);
      if (overrideMatch) {
        overriddenAnniversaryIds.add(overrideMatch[1]);
      }
    }
  });

  // Note: We generate for all companies here because the filtering is applied later in filteredEvents
  // This allows the CalendarBusinessService.filterEventsByCompany to handle the filtering consistently
  const anniversaryEvents = CompanyAnniversaryService.generateAnniversaryEventsForCompanies(
    companies, 
    startDate, 
    endDate
  ).map(anniversaryEvent => CompanyAnniversaryService.convertToCalendarEvent(anniversaryEvent))
   .filter(event => {
    // Filter out anniversary events that have been overridden or deleted
    return !overriddenAnniversaryIds.has(event.id) && !deletedAnniversaryIds.has(event.id);
  });

  // Auto-sync anniversary events to Google Calendar when they're first loaded
  useEffect(() => {
    const autoSyncAnniversaryEvents = async () => {
      if (user?.id && anniversaryEvents.length > 0) {
        try {
          console.log('Auto-syncing anniversary events to Google Calendar:', {
            userId: user.id,
            eventCount: anniversaryEvents.length,
            events: anniversaryEvents.map(e => ({ id: e.id, title: e.title, date: e.date }))
          });
          
          // Call the bulk auto-sync API endpoint
          const response = await fetch('/api/calendar/auto-generated/sync', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ events: anniversaryEvents })
          });
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
            console.warn('Auto-sync failed with HTTP error:', {
              status: response.status,
              statusText: response.statusText,
              error: errorData.error
            });
          } else {
            const result = await response.json();
            console.log('Auto-sync completed successfully:', result);
          }
        } catch (error) {
          // Silently fail for auto-sync to not disrupt the UI
          console.warn('Auto-sync failed for anniversary events:', error);
        }
      } else {
        console.log('Auto-sync skipped:', {
          hasUser: !!user?.id,
          anniversaryEventCount: anniversaryEvents.length
        });
      }
    };

    autoSyncAnniversaryEvents();
  }, [user?.id, user?.timezoneId, anniversaryEvents.length]); // Re-run when anniversary events change

  // Filter out deletion marker events from being displayed (they should not be visible)
  const visibleDatabaseEvents = databaseEvents.filter(event => {
    const descriptionToCheck = event.rawDescription || event.description;
    return !event.title.startsWith('DELETED_ANNIVERSARY_') && 
           !descriptionToCheck?.includes('[DELETED:');
  });

  // Combine visible database events with anniversary events (filtering already done above)
  const events = [...visibleDatabaseEvents, ...anniversaryEvents];

  // Filter events based on selected company (additional client-side filtering)
  const filteredEvents = CalendarBusinessService.filterEventsByCompany(events, selectedCompany, companies);

  // Form Actions
  const updateFormField = useCallback((field: keyof CalendarEventFormData, value: string | Date | string[]) => {
    setFormData(prev => {
      const newData = {
        ...prev,
        [field]: value
      };
      
      // Handle scope changes intelligently
      if (field === 'eventScope') {
        const isCompanyFiltered = selectedCompany !== 'all';
        const selectedCompanyObj = isCompanyFiltered ? companies.find(c => c.id === selectedCompany) : null;
        
        if (value === 'personal') {
          // Switch to personal: clear company
          newData.company = '';
        } else if (value === 'company') {
          // Switch to company: auto-fill with global company if available
          if (selectedCompanyObj) {
            newData.company = selectedCompanyObj.tradingName;
          }
        }
      }
      
      return newData;
    });
  }, [selectedCompany, companies]);

  // Dialog Management
  const resetDialog = useCallback(() => {
    setEditingEvent(null);
    setFormData(getSmartFormData(selectedCompany, companies));
    setIsDialogOpen(false);
  }, [selectedCompany, companies]);

  const openDialog = useCallback(() => {
    // Reset form to smart defaults when opening dialog
    if (!editingEvent) {
      setFormData(getSmartFormData(selectedCompany, companies));
    }
    setIsDialogOpen(true);
  }, [selectedCompany, companies, editingEvent]);

  const closeDialog = useCallback(() => {
    resetDialog();
  }, [resetDialog]);

  const toggleCalendarWidget = useCallback(() => {
    setIsCalendarWidgetExpanded(prev => !prev);
  }, []);

  const toggleMobileCalendar = useCallback((open?: boolean) => {
    setIsMobileCalendarOpen(open !== undefined ? open : (prev => !prev));
  }, []);

  // Event CRUD Operations
  const handleAddEvent = useCallback(async () => {
    try {
      const validation = CalendarValidationService.validateEventForm(formData);
      
      if (!validation.isValid) {
        throw new Error(validation.errors.join(', '));
      }

      const eventData: CalendarEventCreateRequest = {
        title: formData.title,
        description: formData.description,
        date: formData.date.toISOString(),
        time: formData.time,
        type: formData.type.toUpperCase(),
        priority: formData.priority.toUpperCase(),
        company: formData.company,
        participants: formData.participants,
        companyId: formData.eventScope === 'company' && selectedCompany && selectedCompany !== 'all' ? Number(selectedCompany) : undefined,
        eventScope: formData.eventScope,
        syncEnabled: formData.syncEnabled,
        targetCalendarId: formData.targetCalendarId
      };

      await createEventMutation.mutateAsync(eventData);
      resetDialog();
    } catch (error) {
      console.error('Failed to create event:', error);
      // Error handling is already managed by React Query mutation
    }
  }, [formData, createEventMutation, resetDialog, selectedCompany]);

  // Helper function to clean description for editing
  const cleanDescriptionForEdit = useCallback((description: string): string => {
    if (!description) return description;
    // Remove the [ANNIVERSARY_OVERRIDE:...] marker from the description for editing
    return description.replace(/(\n+)?\[ANNIVERSARY_OVERRIDE:[^\]]+\]\s*$/, '').trim();
  }, []);

  const handleEditEvent = useCallback((event: CalendarEvent) => {
    // Prevent editing of auto-generated anniversary events
    if (event.type === 'anniversary') {
      console.warn('Cannot edit auto-generated anniversary events');
      return;
    }
    
    setEditingEvent(event);
    setFormData({
      title: event.title,
      description: cleanDescriptionForEdit(event.description),
      date: event.date,
      time: event.time,
      type: event.type,
      priority: event.priority,
      company: event.company || '',
      participants: event.participants || [],
      eventScope: event.eventScope || 'personal',
      syncEnabled: event.syncEnabled !== false,
      targetCalendarId: event.targetCalendarId
    });
    setIsDialogOpen(true);
  }, [cleanDescriptionForEdit]);

  const handleUpdateEvent = useCallback(async () => {
    if (!editingEvent) return;
    
    try {
      const validation = CalendarValidationService.validateEventForm(formData);
      
      if (!validation.isValid) {
        throw new Error(validation.errors.join(', '));
      }

      // Check if this is an auto-generated event (anniversary) or an already-converted anniversary event
      const isAutoGenerated = editingEvent.type === 'anniversary' || editingEvent.id?.startsWith('anniversary-');
      const isConvertedAnniversary = editingEvent.rawDescription?.includes('[ANNIVERSARY_OVERRIDE:');
      
      if (isAutoGenerated && !isConvertedAnniversary) {
        // For auto-generated events, create a regular database event and track the anniversary ID
        const originalAnniversaryId = editingEvent.id;
        const eventData: CalendarEventCreateRequest = {
          title: formData.title,
          description: `${formData.description}\n\n[ANNIVERSARY_OVERRIDE:${originalAnniversaryId}]`,
          date: formData.date.toISOString(),
          time: formData.time,
          type: formData.type.toUpperCase(),
          priority: formData.priority.toUpperCase(),
          company: formData.company,
          participants: formData.participants,
          companyId: formData.eventScope === 'company' && selectedCompany && selectedCompany !== 'all' ? Number(selectedCompany) : undefined,
          eventScope: formData.eventScope,
          syncEnabled: formData.syncEnabled,
          targetCalendarId: formData.targetCalendarId
        };
        
        await createEventMutation.mutateAsync(eventData);
      } else if (isConvertedAnniversary) {
        // For already-converted anniversary events, update the existing database event
        const eventData: CalendarEventUpdateRequest = {
          title: formData.title,
          description: `${formData.description}\n\n${editingEvent.rawDescription?.match(/\[ANNIVERSARY_OVERRIDE:[^\]]+\]/)?.[0] || ''}`,
          date: formData.date.toISOString(),
          time: formData.time,
          type: formData.type.toUpperCase(),
          priority: formData.priority.toUpperCase(),
          company: formData.company,
          participants: formData.participants,
          companyId: formData.eventScope === 'company' && selectedCompany && selectedCompany !== 'all' ? Number(selectedCompany) : undefined,
          eventScope: formData.eventScope,
          syncEnabled: formData.syncEnabled,
          targetCalendarId: formData.targetCalendarId
        };

        await updateEventMutation.mutateAsync({ id: editingEvent.id, data: eventData });
      } else {
        // For regular events, update in database as normal
        const eventData: CalendarEventUpdateRequest = {
          title: formData.title,
          description: formData.description,
          date: formData.date.toISOString(),
          time: formData.time,
          type: formData.type.toUpperCase(),
          priority: formData.priority.toUpperCase(),
          company: formData.company,
          participants: formData.participants,
          companyId: formData.eventScope === 'company' && selectedCompany && selectedCompany !== 'all' ? Number(selectedCompany) : undefined,
          eventScope: formData.eventScope,
          syncEnabled: formData.syncEnabled,
          targetCalendarId: formData.targetCalendarId
        };

        await updateEventMutation.mutateAsync({ id: editingEvent.id, data: eventData });
      }
      resetDialog();
    } catch (error) {
      console.error('Failed to update event:', error);
      // Error handling is already managed by React Query mutation
    }
  }, [editingEvent, formData, updateEventMutation, resetDialog, selectedCompany]);

  const handleDeleteEvent = useCallback(async (eventId: string) => {
    try {
      // Check if this is an auto-generated event (anniversary)
      const isAutoGenerated = eventId.startsWith('anniversary-');
      
      if (isAutoGenerated) {
        // For auto-generated events, call the deletion API
        if (user?.id) {
          const response = await fetch('/api/calendar/auto-generated/delete', {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ eventId })
          });
          
          if (response.ok) {
            // Update the local state to reflect the deletion
            const deletedResponse = await fetch('/api/calendar/auto-generated/deleted');
            if (deletedResponse.ok) {
              const { deletedIds } = await deletedResponse.json();
              setDeletedAnniversaryIds(new Set(deletedIds));
            }
            
            // Invalidate cache to refresh the UI
            queryClient.invalidateQueries({ queryKey: ['calendar'] });
          } else {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to delete anniversary event');
          }
        } else {
          throw new Error('User not authenticated');
        }
      } else {
        // For regular database events, delete normally
        await deleteEventMutation.mutateAsync(eventId);
      }
    } catch (error) {
      console.error('Failed to delete event:', error);
      // Error handling is already managed by React Query mutation or thrown above
    }
  }, [deleteEventMutation, user?.id, user?.timezoneId, queryClient]);

  // Filter Actions
  const setFilters = useCallback((newFilters: CalendarEventFilters) => {
    setFiltersState(newFilters);
  }, []);

  const resetFilters = useCallback(() => {
    setFiltersState(initialFilters);
  }, []);

  // Utility Functions
  const getEventsForDate = useCallback((date: Date) => {
    return CalendarBusinessService.getEventsForDate(filteredEvents, date);
  }, [filteredEvents]);

  const getTodaysEvents = useCallback(() => {
    return CalendarBusinessService.getTodaysEvents(filteredEvents);
  }, [filteredEvents]);

  const getUpcomingEvents = useCallback(() => {
    return CalendarBusinessService.getUpcomingEvents(filteredEvents);
  }, [filteredEvents]);

  const getThisWeekEvents = useCallback(() => {
    return CalendarBusinessService.getThisWeekEvents(filteredEvents);
  }, [filteredEvents]);

  const getNotesForEvent = useCallback((eventId: string) => {
    return CalendarBusinessService.getNotesForEvent(notes, eventId);
  }, [notes]);

  const getPriorityColor = useCallback((priority: string) => {
    return CalendarBusinessService.getPriorityColor(priority);
  }, []);

  const formatDate = useCallback((date: Date) => {
    return CalendarBusinessService.formatDate(date);
  }, []);

  const formatDateForInput = useCallback((date: Date) => {
    return CalendarBusinessService.formatDateForInput(date);
  }, []);

  const parseDateFromInput = useCallback((dateString: string) => {
    return CalendarBusinessService.parseDateFromInput(dateString);
  }, []);

  // Data Refresh
  const refetch = useCallback(() => {
    refetchEvents();
  }, [refetchEvents]);

  const invalidateCache = useCallback(() => {
    queryClient.invalidateQueries({ queryKey: ['calendar'] });
  }, [queryClient]);


  const isMutating = createEventMutation.isPending || 
                     updateEventMutation.isPending || 
                     deleteEventMutation.isPending;

  return {
    // Data
    events,
    notes,
    filteredEvents,
    statistics,
    
    // UI State
    selectedDate,
    currentMonth,
    isDialogOpen,
    editingEvent,
    isCalendarWidgetExpanded,
    isMobileCalendarOpen,
    
    // Form State
    formData,
    
    // Loading & Error States
    isLoading,
    isError,
    error: error as Error | null,
    isMutating,
    
    // Infinite Query States
    hasNextPage: hasNextPage || false,
    isFetchingNextPage,
    fetchNextPage,
    
    // Actions
    setSelectedDate,
    setCurrentMonth,
    handleAddEvent,
    handleEditEvent,
    handleUpdateEvent,
    handleDeleteEvent,
    resetDialog,
    openDialog,
    closeDialog,
    toggleCalendarWidget,
    toggleMobileCalendar,
    
    // Form Actions
    updateFormField,
    
    // Filter Actions
    setFilters,
    resetFilters,
    
    // Utility Functions
    getEventsForDate,
    getTodaysEvents,
    getUpcomingEvents,
    getThisWeekEvents,
    getNotesForEvent,
    getPriorityColor,
    formatDate,
    formatDateForInput,
    parseDateFromInput,
    
    // Data Refresh
    refetch,
    invalidateCache
  };
};