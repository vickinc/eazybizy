/**
 * Backend service for managing anniversary events in the database
 * This service handles creating, updating, and managing auto-generated anniversary events
 */

import { prisma } from '@/lib/prisma';
import { 
  getAnniversaryDatesInRange, 
  formatAnniversaryEventTitle, 
  formatAnniversaryEventDescription 
} from '@/utils/companyUtils';

export interface AnniversaryEventData {
  id: string;
  title: string;
  description: string;
  date: Date;
  time: string;
  companyId: number;
  companyName: string;
  yearsOld: number;
}

export class AnniversaryEventService {
  
  /**
   * Generate and store anniversary events for a specific company in a date range
   */
  static async generateAndStoreAnniversaryEvents(
    companyId: number,
    startDate: Date,
    endDate: Date,
    userId?: string
  ): Promise<{ created: number; skipped: number; errors: string[] }> {
    const errors: string[] = [];
    let created = 0;
    let skipped = 0;

    try {
      // Get company data
      const company = await prisma.company.findUnique({
        where: { id: companyId },
        select: {
          id: true,
          tradingName: true,
          registrationDate: true,
          status: true
        }
      });

      if (!company || company.status !== 'Active' || !company.registrationDate) {
        return { created: 0, skipped: 1, errors: [`Company ${companyId} not found or inactive`] };
      }

      // Get anniversary dates in range
      const anniversaryDates = getAnniversaryDatesInRange(
        company.registrationDate,
        startDate,
        endDate
      );

      for (const { date, yearsOld } of anniversaryDates) {
        const anniversaryId = `anniversary-${company.id}-${date.getFullYear()}`;
        
        // Check if this anniversary event already exists
        const existingEvent = await prisma.calendarEvent.findFirst({
          where: {
            OR: [
              { id: anniversaryId },
              {
                AND: [
                  { companyId: company.id },
                  { date: date },
                  { type: 'ANNIVERSARY' },
                  { isAutoGenerated: true }
                ]
              }
            ]
          }
        });

        if (existingEvent) {
          skipped++;
          continue;
        }

        // Create the anniversary event in database
        try {
          await prisma.calendarEvent.create({
            data: {
              id: anniversaryId,
              title: formatAnniversaryEventTitle(company.tradingName, yearsOld),
              description: formatAnniversaryEventDescription(
                company.tradingName,
                company.registrationDate,
                yearsOld
              ),
              date: date,
              time: '09:00',
              type: 'ANNIVERSARY',
              priority: 'MEDIUM',
              company: company.tradingName,
              companyId: company.id,
              participants: '[]',
              eventScope: 'company',
              isAutoGenerated: true,
              createdByUserId: userId,
              timezoneId: 'UTC',
              syncStatus: 'PENDING',
              googleCalendarId: 'primary'
            }
          });
          created++;
        } catch (error) {
          errors.push(`Failed to create anniversary event for ${company.tradingName}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
      }

      return { created, skipped, errors };
    } catch (error) {
      errors.push(`Failed to process company ${companyId}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      return { created, skipped, errors };
    }
  }

  /**
   * Generate anniversary events for all active companies in a date range
   */
  static async generateAndStoreAllAnniversaryEvents(
    startDate: Date,
    endDate: Date,
    userId?: string
  ): Promise<{ totalCreated: number; totalSkipped: number; errors: string[] }> {
    const allErrors: string[] = [];
    let totalCreated = 0;
    let totalSkipped = 0;

    try {
      // Get all active companies with registration dates
      const companies = await prisma.company.findMany({
        where: {
          status: 'Active',
          registrationDate: { not: null as any }
        },
        select: {
          id: true,
          tradingName: true,
          registrationDate: true
        }
      });

      console.log(`Processing ${companies.length} active companies for anniversary events`);

      // Process each company
      for (const company of companies) {
        if (!company.registrationDate) continue;

        const result = await this.generateAndStoreAnniversaryEvents(
          company.id,
          startDate,
          endDate,
          userId
        );

        totalCreated += result.created;
        totalSkipped += result.skipped;
        allErrors.push(...result.errors);
      }

      console.log(`Anniversary event generation completed: ${totalCreated} created, ${totalSkipped} skipped, ${allErrors.length} errors`);

      return {
        totalCreated,
        totalSkipped,
        errors: allErrors
      };
    } catch (error) {
      const errorMessage = `Failed to generate anniversary events: ${error instanceof Error ? error.message : 'Unknown error'}`;
      allErrors.push(errorMessage);
      console.error(errorMessage, error);
      
      return {
        totalCreated,
        totalSkipped,
        errors: allErrors
      };
    }
  }

  /**
   * Clean up old anniversary events (older than 2 years)
   */
  static async cleanupOldAnniversaryEvents(): Promise<{ deleted: number; errors: string[] }> {
    const errors: string[] = [];
    let deleted = 0;

    try {
      const twoYearsAgo = new Date();
      twoYearsAgo.setFullYear(twoYearsAgo.getFullYear() - 2);

      const result = await prisma.calendarEvent.deleteMany({
        where: {
          isAutoGenerated: true,
          type: 'ANNIVERSARY',
          date: { lt: twoYearsAgo }
        }
      });

      deleted = result.count;
      console.log(`Cleaned up ${deleted} old anniversary events`);

      return { deleted, errors };
    } catch (error) {
      const errorMessage = `Failed to cleanup old anniversary events: ${error instanceof Error ? error.message : 'Unknown error'}`;
      errors.push(errorMessage);
      console.error(errorMessage, error);
      
      return { deleted: 0, errors };
    }
  }

  /**
   * Get upcoming anniversary events for the next 30 days
   */
  static async getUpcomingAnniversaryEvents(companyId?: number): Promise<AnniversaryEventData[]> {
    try {
      const today = new Date();
      const thirtyDaysFromNow = new Date();
      thirtyDaysFromNow.setDate(today.getDate() + 30);

      const events = await prisma.calendarEvent.findMany({
        where: {
          isAutoGenerated: true,
          type: 'ANNIVERSARY',
          date: {
            gte: today,
            lte: thirtyDaysFromNow
          },
          ...(companyId && { companyId })
        },
        include: {
          companyRecord: {
            select: {
              tradingName: true
            }
          }
        },
        orderBy: {
          date: 'asc'
        }
      });

      return events.map(event => ({
        id: event.id,
        title: event.title,
        description: event.description,
        date: event.date,
        time: event.time,
        companyId: event.companyId!,
        companyName: event.companyRecord?.tradingName || event.company || '',
        yearsOld: this.extractYearsFromTitle(event.title)
      }));
    } catch (error) {
      console.error('Failed to get upcoming anniversary events:', error);
      return [];
    }
  }

  /**
   * Update anniversary events when company data changes
   */
  static async updateAnniversaryEventsForCompany(
    companyId: number,
    oldTradingName?: string,
    newTradingName?: string,
    newRegistrationDate?: Date
  ): Promise<{ updated: number; errors: string[] }> {
    const errors: string[] = [];
    let updated = 0;

    try {
      // If registration date changed, we need to regenerate all anniversary events
      if (newRegistrationDate) {
        // Delete old anniversary events
        await prisma.calendarEvent.deleteMany({
          where: {
            companyId,
            isAutoGenerated: true,
            type: 'ANNIVERSARY'
          }
        });

        // Generate new ones for the next 2 years
        const endDate = new Date();
        endDate.setFullYear(endDate.getFullYear() + 2);
        
        const result = await this.generateAndStoreAnniversaryEvents(
          companyId,
          new Date(),
          endDate
        );
        
        updated = result.created;
        errors.push(...result.errors);
      } 
      // If only trading name changed, update existing events
      else if (newTradingName && oldTradingName !== newTradingName) {
        const company = await prisma.company.findUnique({
          where: { id: companyId },
          select: { registrationDate: true }
        });

        if (company?.registrationDate) {
          const anniversaryEvents = await prisma.calendarEvent.findMany({
            where: {
              companyId,
              isAutoGenerated: true,
              type: 'ANNIVERSARY'
            }
          });

          for (const event of anniversaryEvents) {
            const yearsOld = this.extractYearsFromTitle(event.title);
            
            const updateData = {
              title: formatAnniversaryEventTitle(newTradingName, yearsOld),
              description: formatAnniversaryEventDescription(
                newTradingName,
                company.registrationDate,
                yearsOld
              ),
              company: newTradingName
            };

            await prisma.calendarEvent.update({
              where: { id: event.id },
              data: updateData
            });
            
            updated++;
          }
        }
      }

      return { updated, errors };
    } catch (error) {
      const errorMessage = `Failed to update anniversary events for company ${companyId}: ${error instanceof Error ? error.message : 'Unknown error'}`;
      errors.push(errorMessage);
      console.error(errorMessage, error);
      
      return { updated, errors };
    }
  }

  /**
   * Delete all anniversary events for a company (when company is deleted/deactivated)
   */
  static async deleteAnniversaryEventsForCompany(companyId: number): Promise<{ deleted: number; errors: string[] }> {
    const errors: string[] = [];
    
    try {
      const result = await prisma.calendarEvent.deleteMany({
        where: {
          companyId,
          isAutoGenerated: true,
          type: 'ANNIVERSARY'
        }
      });

      console.log(`Deleted ${result.count} anniversary events for company ${companyId}`);
      
      return { deleted: result.count, errors };
    } catch (error) {
      const errorMessage = `Failed to delete anniversary events for company ${companyId}: ${error instanceof Error ? error.message : 'Unknown error'}`;
      errors.push(errorMessage);
      console.error(errorMessage, error);
      
      return { deleted: 0, errors };
    }
  }

  /**
   * Helper method to extract years from anniversary title
   */
  private static extractYearsFromTitle(title: string): number {
    const match = title.match(/(\d+)\s*(st|nd|rd|th)\s*Anniversary/i);
    if (match) {
      return parseInt(match[1], 10);
    }
    
    // Handle "registration day" case
    if (title.includes('Registration Day')) {
      return 0;
    }
    
    return 0;
  }

  /**
   * Sync anniversary events for a specific time period (used by scheduled jobs)
   */
  static async syncAnniversaryEventsForPeriod(
    startDate: Date,
    endDate: Date,
    userId?: string
  ): Promise<{ success: boolean; message: string; stats: { created: number; skipped: number; errors: number } }> {
    try {
      console.log(`Starting anniversary event sync for period ${startDate.toISOString()} to ${endDate.toISOString()}`);
      
      const result = await this.generateAndStoreAllAnniversaryEvents(startDate, endDate, userId);
      
      const stats = {
        created: result.totalCreated,
        skipped: result.totalSkipped,
        errors: result.errors.length
      };

      if (result.errors.length > 0) {
        console.warn('Anniversary event sync completed with errors:', result.errors);
        return {
          success: false,
          message: `Sync completed with ${result.errors.length} errors`,
          stats
        };
      }

      return {
        success: true,
        message: `Successfully synced anniversary events: ${result.totalCreated} created, ${result.totalSkipped} skipped`,
        stats
      };
    } catch (error) {
      console.error('Anniversary event sync failed:', error);
      return {
        success: false,
        message: `Sync failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        stats: { created: 0, skipped: 0, errors: 1 }
      };
    }
  }
}