/**
 * Smart Anniversary Rollover Service
 * 
 * Handles automatic generation of next year's anniversary events when current ones pass.
 * Uses event-driven approach triggered by normal application usage, no cron jobs required.
 */

import { prisma } from '@/lib/prisma';
import { AnniversaryEventService } from './anniversaryEventService';

export interface RolloverResult {
  processed: number;
  created: number;
  skipped: number;
  errors: string[];
  companies: Array<{
    companyId: number;
    companyName: string;
    newEvent: {
      title: string;
      date: string;
      yearsOld: number;
    };
  }>;
}

export class AnniversarySmartRollover {
  // Cache to prevent excessive rollover checks (in-memory for simplicity)
  private static lastRolloverCheck: { [companyId: number]: Date } = {};
  private static globalLastCheck: Date | null = null;

  /**
   * Main method to check and generate next anniversary events for passed anniversaries
   */
  static async checkAndGenerateNextAnniversaries(
    companyId?: number,
    userId?: string
  ): Promise<RolloverResult> {
    const result: RolloverResult = {
      processed: 0,
      created: 0,
      skipped: 0,
      errors: [],
      companies: []
    };

    try {
      // Check if we should skip this check based on cache
      if (this.shouldSkipRolloverCheck(companyId)) {
        return result;
      }

      // Get passed anniversary events that need rollover
      const passedEvents = await this.getPassedAnniversaryEvents(companyId);
      
      if (passedEvents.length === 0) {
        this.updateRolloverCache(companyId);
        return result;
      }

      console.log(`Found ${passedEvents.length} passed anniversary events that need rollover`);

      // Group events by company to process efficiently
      const eventsByCompany = this.groupEventsByCompany(passedEvents);

      // Process each company's passed anniversaries
      for (const [companyIdStr, events] of eventsByCompany.entries()) {
        const currentCompanyId = parseInt(companyIdStr);
        
        try {
          const companyResult = await this.processCompanyAnniversaries(
            currentCompanyId,
            events,
            userId
          );
          
          result.processed++;
          result.created += companyResult.created;
          result.skipped += companyResult.skipped;
          result.companies.push(...companyResult.companies);
          result.errors.push(...companyResult.errors);
          
        } catch (error) {
          const errorMsg = `Failed to process anniversaries for company ${currentCompanyId}: ${error instanceof Error ? error.message : 'Unknown error'}`;
          result.errors.push(errorMsg);
          console.error(errorMsg, error);
        }
      }

      // Update cache after successful rollover
      this.updateRolloverCache(companyId);

      console.log(`Anniversary rollover completed: ${result.created} events created, ${result.skipped} skipped, ${result.errors.length} errors`);

      return result;
    } catch (error) {
      const errorMsg = `Anniversary rollover failed: ${error instanceof Error ? error.message : 'Unknown error'}`;
      result.errors.push(errorMsg);
      console.error(errorMsg, error);
      return result;
    }
  }

  /**
   * Get anniversary events that have passed and need next year's event generated
   */
  private static async getPassedAnniversaryEvents(
    companyId?: number
  ): Promise<Array<{
    id: string;
    companyId: number;
    companyName: string;
    date: Date;
    title: string;
    registrationDate: Date;
    yearsOld: number;
  }>> {
    const today = new Date();
    today.setHours(0, 0, 0, 0); // Start of today

    const events = await prisma.calendarEvent.findMany({
      where: {
        isAutoGenerated: true,
        type: 'ANNIVERSARY',
        date: { lt: today }, // Events that have passed
        ...(companyId && { companyId })
      },
      include: {
        companyRecord: {
          select: {
            tradingName: true,
            registrationDate: true
          }
        }
      },
      orderBy: {
        date: 'desc'
      }
    });

    // Filter to only include events that don't have next year's event yet
    const eventsNeedingRollover = [];
    
    for (const event of events) {
      if (!event.companyRecord?.registrationDate) continue;
      
      const yearsOld = this.extractYearsFromTitle(event.title);
      const nextYear = yearsOld + 1;
      
      // Check if next year's anniversary already exists
      const nextYearDate = new Date(event.companyRecord.registrationDate);
      nextYearDate.setFullYear(nextYearDate.getFullYear() + nextYear);
      
      const existingNextEvent = await prisma.calendarEvent.findFirst({
        where: {
          companyId: event.companyId,
          isAutoGenerated: true,
          type: 'ANNIVERSARY',
          date: nextYearDate
        }
      });

      if (!existingNextEvent) {
        eventsNeedingRollover.push({
          id: event.id,
          companyId: event.companyId!,
          companyName: event.companyRecord.tradingName,
          date: event.date,
          title: event.title,
          registrationDate: event.companyRecord.registrationDate,
          yearsOld
        });
      }
    }

    return eventsNeedingRollover;
  }

  /**
   * Process anniversaries for a specific company
   */
  private static async processCompanyAnniversaries(
    companyId: number,
    events: Array<{
      id: string;
      companyId: number;
      companyName: string;
      date: Date;
      title: string;
      registrationDate: Date;
      yearsOld: number;
    }>,
    userId?: string
  ): Promise<{
    created: number;
    skipped: number;
    errors: string[];
    companies: Array<{
      companyId: number;
      companyName: string;
      newEvent: {
        title: string;
        date: string;
        yearsOld: number;
      };
    }>;
  }> {
    const result = {
      created: 0,
      skipped: 0,
      errors: [],
      companies: []
    };

    // Find the latest passed anniversary for this company
    const latestEvent = events.reduce((latest, current) => 
      current.yearsOld > latest.yearsOld ? current : latest
    );

    const nextYear = latestEvent.yearsOld + 1;
    const nextAnniversaryDate = new Date(latestEvent.registrationDate);
    nextAnniversaryDate.setFullYear(nextAnniversaryDate.getFullYear() + nextYear);

    // Generate next year's anniversary using existing service
    const generateResult = await AnniversaryEventService.generateAndStoreAnniversaryEvents(
      companyId,
      nextAnniversaryDate,
      nextAnniversaryDate,
      userId
    );

    result.created = generateResult.created;
    result.skipped = generateResult.skipped;
    result.errors = generateResult.errors;

    if (generateResult.created > 0) {
      result.companies.push({
        companyId,
        companyName: latestEvent.companyName,
        newEvent: {
          title: `${latestEvent.companyName} - ${nextYear}${this.getOrdinalSuffix(nextYear)} Anniversary`,
          date: nextAnniversaryDate.toISOString(),
          yearsOld: nextYear
        }
      });
    }

    return result;
  }

  /**
   * Group events by company ID for efficient processing
   */
  private static groupEventsByCompany(
    events: Array<{ companyId: number; [key: string]: any }>
  ): Map<string, Array<any>> {
    const grouped = new Map<string, Array<any>>();
    
    for (const event of events) {
      const companyId = event.companyId.toString();
      if (!grouped.has(companyId)) {
        grouped.set(companyId, []);
      }
      grouped.get(companyId)!.push(event);
    }
    
    return grouped;
  }

  /**
   * Check if rollover check should be skipped based on cache
   */
  private static shouldSkipRolloverCheck(companyId?: number): boolean {
    const now = new Date();
    const cacheValidHours = 24; // Only check once per day maximum (increased from 12 to reduce load)

    if (companyId) {
      const lastCheck = this.lastRolloverCheck[companyId];
      if (lastCheck) {
        const hoursSinceCheck = (now.getTime() - lastCheck.getTime()) / (1000 * 60 * 60);
        if (hoursSinceCheck < cacheValidHours) {
          return true; // Skip check
        }
      }
    } else {
      // Global check
      if (this.globalLastCheck) {
        const hoursSinceCheck = (now.getTime() - this.globalLastCheck.getTime()) / (1000 * 60 * 60);
        if (hoursSinceCheck < cacheValidHours) {
          return true; // Skip check
        }
      }
    }

    return false; // Don't skip check
  }

  /**
   * Update rollover cache timestamps
   */
  private static updateRolloverCache(companyId?: number): void {
    const now = new Date();
    
    if (companyId) {
      this.lastRolloverCheck[companyId] = now;
    } else {
      this.globalLastCheck = now;
    }
  }

  /**
   * Extract years from anniversary title (reuse logic from AnniversaryEventService)
   */
  private static extractYearsFromTitle(title: string): number {
    const match = title.match(/(\d+)\s*(st|nd|rd|th)\s*Anniversary/i);
    if (match) {
      return parseInt(match[1], 10);
    }
    
    // Handle "registration day" case
    if (title.includes('Registration Day')) {
      return 0;
    }
    
    return 0;
  }

  /**
   * Get ordinal suffix for numbers (1st, 2nd, 3rd, 4th, etc.)
   */
  private static getOrdinalSuffix(num: number): string {
    const lastDigit = num % 10;
    const lastTwoDigits = num % 100;
    
    if (lastTwoDigits >= 11 && lastTwoDigits <= 13) {
      return 'th';
    }
    
    switch (lastDigit) {
      case 1: return 'st';
      case 2: return 'nd';
      case 3: return 'rd';
      default: return 'th';
    }
  }

  /**
   * Force rollover check (bypass cache) - useful for testing or manual triggers
   */
  static async forceRolloverCheck(companyId?: number, userId?: string): Promise<RolloverResult> {
    // Clear relevant cache
    if (companyId) {
      delete this.lastRolloverCheck[companyId];
    } else {
      this.globalLastCheck = null;
      this.lastRolloverCheck = {};
    }

    return this.checkAndGenerateNextAnniversaries(companyId, userId);
  }
}