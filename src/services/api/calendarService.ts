import { CalendarEvent, Note } from '@/types/calendar.types';

// API Response Types
export interface CalendarEventResponse {
  id: string;
  title: string;
  description: string;
  date: string; // ISO string from API
  time: string;
  type: string;
  priority: string;
  company?: string;
  participants: string | string[]; // JSON string from API or array
  companyId?: number;
  isAutoGenerated?: boolean;
  createdAt: string;
  updatedAt: string;
  notes?: NoteResponse[];
  companyRecord?: {
    id: number;
    legalName: string;
    tradingName: string;
  };
}

export interface NoteResponse {
  id: string;
  title: string;
  content: string;
  eventId?: string;
  companyId?: number;
  tags: string | string[]; // JSON string from API or array
  priority: string;
  isStandalone: boolean;
  isCompleted: boolean;
  completedAt?: string;
  isAutoArchived: boolean;
  createdAt: string;
  updatedAt: string;
  event?: {
    id: string;
    title: string;
    date: string;
    time: string;
  };
  company?: {
    id: number;
    legalName: string;
    tradingName: string;
  };
}

export interface CalendarEventsPaginatedResponse {
  events: CalendarEventResponse[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    pages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

export interface CalendarEventsCursorResponse {
  events: CalendarEventResponse[];
  pagination: {
    hasMore: boolean;
    nextCursor: string | null;
    limit: number;
    count: number;
  };
}

export interface CalendarStatisticsResponse {
  totalEvents: number;
  upcomingEvents: number;
  pastEvents: number;
  eventsByType: Array<{ type: string; count: number }>;
  eventsByPriority: Array<{ priority: string; count: number }>;
  eventsByMonth: Array<{ month: string; count: number }>;
  lastUpdated: string;
}

export interface CalendarEventFilters {
  companyId?: string;
  type?: string;
  priority?: string;
  search?: string;
  dateFrom?: string;
  dateTo?: string;
  // New comprehensive filters
  date?: string; // Specific date (YYYY-MM-DD)
  dateRange?: 'today' | 'week' | 'month' | 'upcoming';
  limit?: number;
  sortBy?: 'date' | 'createdAt' | 'priority' | 'title' | 'time';
  sortOrder?: 'asc' | 'desc';
  includeCompleted?: boolean;
  isAutoGenerated?: boolean;
}

export interface CalendarEventCreateRequest {
  title: string;
  description?: string;
  date: string; // ISO string
  time: string;
  type?: string;
  priority?: string;
  company?: string;
  participants?: string[];
  companyId?: number;
  eventScope?: string;
  syncEnabled?: boolean;
  targetCalendarId?: string;
}

export interface CalendarEventUpdateRequest {
  title?: string;
  description?: string;
  date?: string; // ISO string
  time?: string;
  type?: string;
  priority?: string;
  company?: string;
  participants?: string[];
  companyId?: number;
  eventScope?: string;
  syncEnabled?: boolean;
  targetCalendarId?: string;
}

export interface NoteCreateRequest {
  title: string;
  content: string;
  eventId?: string;
  companyId?: number;
  tags?: string[];
  priority?: string;
  isStandalone?: boolean;
}

export interface NoteUpdateRequest {
  title?: string;
  content?: string;
  tags?: string[];
  priority?: string;
  isCompleted?: boolean;
  isStandalone?: boolean;
  eventId?: string;
  companyId?: number;
}

export class CalendarService {
  private baseUrl = '/api/calendar';

  // Clean up description by removing override markers for display
  private cleanDescription(description: string): string {
    if (!description) return description;
    // Remove the [ANNIVERSARY_OVERRIDE:...] marker from the description for display
    return description.replace(/(\n+)?\[ANNIVERSARY_OVERRIDE:[^\]]+\]\s*$/, '').trim();
  }

  // Transform API response to client format
  private transformEventResponse(event: CalendarEventResponse): CalendarEvent {
    let participants: string[] = [];
    
    // Safely handle participants field - could be string (JSON) or array
    if (event.participants) {
      if (Array.isArray(event.participants)) {
        participants = event.participants;
      } else if (typeof event.participants === 'string' && event.participants.trim()) {
        try {
          const parsed = JSON.parse(event.participants);
          participants = Array.isArray(parsed) ? parsed : [];
        } catch (error) {
          console.warn('Failed to parse participants JSON for event:', event.title, 'Data:', event.participants);
          participants = [];
        }
      }
    }
    
    return {
      id: event.id,
      title: event.title,
      description: this.cleanDescription(event.description),
      rawDescription: event.description, // Preserve original for logic
      date: new Date(event.date),
      time: event.time,
      type: event.type.toLowerCase() as CalendarEvent['type'],
      priority: event.priority.toLowerCase() as CalendarEvent['priority'],
      company: event.company,
      participants,
      isAutoGenerated: event.isAutoGenerated || false,
      companyId: event.companyId,
      eventScope: (event.companyId ? 'company' : 'personal') as CalendarEvent['eventScope']
    };
  }

  private transformNoteResponse(note: NoteResponse): Note {
    let tags: string[] = [];
    
    // Safely handle tags field - could be string (JSON) or array
    if (note.tags) {
      if (Array.isArray(note.tags)) {
        tags = note.tags;
      } else if (typeof note.tags === 'string' && note.tags.trim()) {
        try {
          const parsed = JSON.parse(note.tags);
          tags = Array.isArray(parsed) ? parsed : [];
        } catch (error) {
          console.warn('Failed to parse tags JSON for note:', note.title, 'Data:', note.tags);
          tags = [];
        }
      }
    }
    
    return {
      id: note.id,
      title: note.title,
      content: note.content,
      eventId: note.eventId,
      companyId: note.companyId,
      tags,
      priority: note.priority.toLowerCase() as Note['priority'],
      isStandalone: note.isStandalone,
      isCompleted: note.isCompleted,
      completedAt: note.completedAt ? new Date(note.completedAt) : undefined,
      isAutoArchived: note.isAutoArchived,
      createdAt: new Date(note.createdAt),
      updatedAt: new Date(note.updatedAt)
    };
  }

  // Calendar Events API
  async getEvents(
    page: number = 1,
    limit: number = 50,
    filters: CalendarEventFilters = {}
  ): Promise<{ events: CalendarEvent[]; pagination: CalendarEventsPaginatedResponse['pagination'] }> {
    const params = new URLSearchParams({
      page: page.toString(),
      limit: limit.toString(),
      ...Object.fromEntries(
        Object.entries(filters).filter(([_, value]) => value !== undefined && value !== '')
      )
    });

    const response = await fetch(`${this.baseUrl}/events/fast?${params}`);
    if (!response.ok) {
      throw new Error(`Failed to fetch events: ${response.statusText}`);
    }

    const data: CalendarEventsPaginatedResponse = await response.json();
    return {
      events: data.events.map(event => this.transformEventResponse(event)),
      pagination: data.pagination
    };
  }

  async getEventsWithCursor(
    cursor?: string,
    limit: number = 20,
    sortDirection: 'asc' | 'desc' = 'desc',
    filters: CalendarEventFilters = {}
  ): Promise<{ events: CalendarEvent[]; pagination: CalendarEventsCursorResponse['pagination'] }> {
    const params = new URLSearchParams({
      limit: limit.toString(),
      sortDirection,
      ...Object.fromEntries(
        Object.entries(filters).filter(([_, value]) => value !== undefined && value !== '')
      )
    });

    if (cursor) {
      params.set('cursor', cursor);
    }

    const response = await fetch(`${this.baseUrl}/events/cursor?${params}`);
    if (!response.ok) {
      throw new Error(`Failed to fetch events with cursor: ${response.statusText}`);
    }

    const data: CalendarEventsCursorResponse = await response.json();
    return {
      events: data.events.map(event => this.transformEventResponse(event)),
      pagination: data.pagination
    };
  }

  async getEvent(id: string): Promise<CalendarEvent> {
    const response = await fetch(`${this.baseUrl}/events/${id}`);
    if (!response.ok) {
      throw new Error(`Failed to fetch event: ${response.statusText}`);
    }

    const event: CalendarEventResponse = await response.json();
    return this.transformEventResponse(event);
  }

  async createEvent(eventData: CalendarEventCreateRequest): Promise<CalendarEvent> {
    const response = await fetch(`${this.baseUrl}/events`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(eventData)
    });

    if (!response.ok) {
      throw new Error(`Failed to create event: ${response.statusText}`);
    }

    const event: CalendarEventResponse = await response.json();
    return this.transformEventResponse(event);
  }

  async updateEvent(id: string, eventData: CalendarEventUpdateRequest): Promise<CalendarEvent> {
    const response = await fetch(`${this.baseUrl}/events/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(eventData)
    });

    if (!response.ok) {
      throw new Error(`Failed to update event: ${response.statusText}`);
    }

    const event: CalendarEventResponse = await response.json();
    return this.transformEventResponse(event);
  }

  async deleteEvent(id: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/events/${id}`, {
      method: 'DELETE'
    });

    if (!response.ok) {
      let errorMessage = response.statusText;
      try {
        const errorData = await response.json();
        errorMessage = errorData.error || response.statusText;
      } catch (e) {
        // If we can't parse JSON, use statusText
      }
      throw new Error(`Failed to delete event: ${errorMessage}`);
    }
  }

  // Calendar Statistics
  async getStatistics(companyId?: string): Promise<CalendarStatisticsResponse> {
    const params = new URLSearchParams();
    if (companyId && companyId !== 'all') {
      params.set('companyId', companyId);
    }

    const response = await fetch(`${this.baseUrl}/events/statistics?${params}`);
    if (!response.ok) {
      throw new Error(`Failed to fetch statistics: ${response.statusText}`);
    }

    return response.json();
  }

  async invalidateStatistics(): Promise<void> {
    const response = await fetch(`${this.baseUrl}/events/statistics/invalidate`, {
      method: 'POST'
    });

    if (!response.ok) {
      throw new Error(`Failed to invalidate statistics: ${response.statusText}`);
    }
  }

  // Notes API
  async getNotes(
    page: number = 1,
    limit: number = 50,
    filters: {
      eventId?: string;
      companyId?: string;
      priority?: string;
      isCompleted?: boolean;
      isStandalone?: boolean;
      search?: string;
    } = {}
  ): Promise<{ notes: Note[]; pagination: unknown }> {
    const params = new URLSearchParams({
      page: page.toString(),
      limit: limit.toString(),
      ...Object.fromEntries(
        Object.entries(filters)
          .filter(([_, value]) => value !== undefined && value !== '')
          .map(([key, value]) => [key, value.toString()])
      )
    });

    const response = await fetch(`${this.baseUrl}/notes?${params}`);
    if (!response.ok) {
      throw new Error(`Failed to fetch notes: ${response.statusText}`);
    }

    const data = await response.json();
    return {
      notes: data.notes.map((note: NoteResponse) => this.transformNoteResponse(note)),
      pagination: data.pagination
    };
  }

  async getNote(id: string): Promise<Note> {
    const response = await fetch(`${this.baseUrl}/notes/${id}`);
    if (!response.ok) {
      throw new Error(`Failed to fetch note: ${response.statusText}`);
    }

    const note: NoteResponse = await response.json();
    return this.transformNoteResponse(note);
  }

  async createNote(noteData: NoteCreateRequest): Promise<Note> {
    const response = await fetch(`${this.baseUrl}/notes`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(noteData)
    });

    if (!response.ok) {
      throw new Error(`Failed to create note: ${response.statusText}`);
    }

    const note: NoteResponse = await response.json();
    return this.transformNoteResponse(note);
  }

  async updateNote(id: string, noteData: NoteUpdateRequest): Promise<Note> {
    const response = await fetch(`${this.baseUrl}/notes/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(noteData)
    });

    if (!response.ok) {
      throw new Error(`Failed to update note: ${response.statusText}`);
    }

    const note: NoteResponse = await response.json();
    return this.transformNoteResponse(note);
  }

  async deleteNote(id: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/notes/${id}`, {
      method: 'DELETE'
    });

    if (!response.ok) {
      throw new Error(`Failed to delete note: ${response.statusText}`);
    }
  }

  // ========================================
  // Backend-Filtered Event Queries
  // ========================================

  /**
   * Get events for a specific date (backend filtered)
   */
  async getEventsForDate(
    date: Date,
    companyId?: string,
    limit: number = 50
  ): Promise<{ events: CalendarEvent[]; count: number }> {
    const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD format
    
    const filters: CalendarEventFilters = {
      date: dateStr,
      companyId,
      limit,
      sortBy: 'time',
      sortOrder: 'asc'
    };

    const result = await this.getEventsWithCursor(undefined, limit, 'asc', filters);
    return {
      events: result.events,
      count: result.events.length
    };
  }

  /**
   * Get today's events (backend filtered)
   */
  async getTodaysEvents(
    companyId?: string,
    limit: number = 50
  ): Promise<{ events: CalendarEvent[]; count: number }> {
    return this.getEventsForDate(new Date(), companyId, limit);
  }

  /**
   * Get upcoming events (backend filtered)
   */
  async getUpcomingEvents(
    companyId?: string,
    limit: number = 10
  ): Promise<{ events: CalendarEvent[]; count: number }> {
    const filters: CalendarEventFilters = {
      dateRange: 'upcoming',
      companyId,
      limit,
      sortBy: 'date',
      sortOrder: 'asc'
    };

    const result = await this.getEventsWithCursor(undefined, limit, 'asc', filters);
    return {
      events: result.events,
      count: result.events.length
    };
  }

  /**
   * Get this week's events (backend filtered)
   */
  async getThisWeekEvents(
    companyId?: string,
    limit: number = 50
  ): Promise<{ events: CalendarEvent[]; count: number }> {
    const filters: CalendarEventFilters = {
      dateRange: 'week',
      companyId,
      limit,
      sortBy: 'date',
      sortOrder: 'asc'
    };

    const result = await this.getEventsWithCursor(undefined, limit, 'asc', filters);
    return {
      events: result.events,
      count: result.events.length
    };
  }

  /**
   * Get this month's events (backend filtered)
   */
  async getThisMonthEvents(
    companyId?: string,
    limit: number = 100
  ): Promise<{ events: CalendarEvent[]; count: number }> {
    const filters: CalendarEventFilters = {
      dateRange: 'month',
      companyId,
      limit,
      sortBy: 'date',
      sortOrder: 'asc'
    };

    const result = await this.getEventsWithCursor(undefined, limit, 'asc', filters);
    return {
      events: result.events,
      count: result.events.length
    };
  }

  /**
   * Get events with comprehensive backend filtering
   */
  async getFilteredEvents(
    filters: CalendarEventFilters,
    cursor?: string,
    limit: number = 20
  ): Promise<{ events: CalendarEvent[]; pagination: CalendarEventsCursorResponse['pagination'] }> {
    return this.getEventsWithCursor(cursor, limit, filters.sortOrder || 'desc', filters);
  }
}