/**
 * PostgreSQL Data Import Script
 * Imports data from exported JSON files into PostgreSQL database
 */

const { PrismaClient } = require('@prisma/client');
const fs = require('fs');
const path = require('path');

const IMPORT_DIR = path.join(__dirname, '../migration-data');

// Import order (same as export order)
const TABLE_IMPORT_ORDER = [
  'users',
  'companies', 
  'company_memberships',
  'audit_logs',
  'shareholders',
  'representatives',
  'clients',
  'vendors',
  'products',
  'bank_accounts',
  'digital_wallets',
  'payment_methods',
  'company_accounts',
  'chart_of_accounts',
  'tax_treatments',
  'invoices',
  'invoice_items',
  'payment_method_invoices',
  'invoice_payment_sources',
  'bookkeeping_entries',
  'transactions',
  'transaction_attachments',
  'journal_entries',
  'journal_entry_lines',
  'calendar_events',
  'google_calendar_syncs',
  'auto_generated_event_syncs',
  'notes',
  'business_cards'
];

// Map SQLite table names to Prisma model names
const TABLE_TO_MODEL_MAP = {
  'users': 'user',
  'companies': 'company',
  'company_memberships': 'companyMembership',
  'audit_logs': 'auditLog',
  'shareholders': 'shareholder',
  'representatives': 'representative',
  'clients': 'client',
  'vendors': 'vendor',
  'products': 'product',
  'bank_accounts': 'bankAccount',
  'digital_wallets': 'digitalWallet',
  'payment_methods': 'paymentMethod',
  'company_accounts': 'companyAccount',
  'chart_of_accounts': 'chartOfAccount',
  'tax_treatments': 'taxTreatment',
  'invoices': 'invoice',
  'invoice_items': 'invoiceItem',
  'payment_method_invoices': 'paymentMethodInvoice',
  'invoice_payment_sources': 'invoicePaymentSource',
  'bookkeeping_entries': 'bookkeepingEntry',
  'transactions': 'transaction',
  'transaction_attachments': 'transactionAttachment',
  'journal_entries': 'journalEntry',
  'journal_entry_lines': 'journalEntryLine',
  'calendar_events': 'calendarEvent',
  'google_calendar_syncs': 'googleCalendarSync',
  'auto_generated_event_syncs': 'autoGeneratedEventSync',
  'notes': 'note',
  'business_cards': 'businessCard'
};

class PostgreSQLDataImporter {
  constructor() {
    this.prisma = new PrismaClient({
      log: ['error', 'warn'],
    });
    this.importStats = {};
    this.errors = [];
  }

  async connect() {
    try {
      await this.prisma.$connect();
      console.log('Connected to PostgreSQL database');
    } catch (error) {
      console.error('Failed to connect to PostgreSQL:', error);
      throw error;
    }
  }

  loadTableData(tableName) {
    const filePath = path.join(IMPORT_DIR, `${tableName}.json`);
    
    if (!fs.existsSync(filePath)) {
      console.log(`‚ö†Ô∏è  No data file found for ${tableName}, skipping...`);
      return null;
    }

    try {
      const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
      return data;
    } catch (error) {
      console.error(`Error reading ${tableName} data:`, error);
      return null;
    }
  }

  transformDataForPostgreSQL(tableName, data) {
    return data.map(record => {
      const transformed = { ...record };

      // Handle date fields - convert strings/timestamps to Date objects
      Object.keys(transformed).forEach(key => {
        // Handle timestamp integers from SQLite (common for dates)
        if (typeof transformed[key] === 'number' && transformed[key] > 1000000000000) {
          // This looks like a timestamp in milliseconds
          if (key.includes('Date') || key.includes('At') || key === 'date' || 
              key === 'timestamp' || key === 'time') {
            try {
              transformed[key] = new Date(transformed[key]);
            } catch (e) {
              // Keep original value if date parsing fails
            }
          }
        }
        
        // Handle date strings
        if (transformed[key] && typeof transformed[key] === 'string') {
          // Common date field patterns
          if (key.includes('Date') || key.includes('At') || key === 'date' || 
              key === 'timestamp' || key === 'time') {
            try {
              const date = new Date(transformed[key]);
              if (!isNaN(date.getTime())) {
                transformed[key] = date;
              }
            } catch (e) {
              // Keep original value if date parsing fails
            }
          }
        }

        // Handle numeric fields that might be strings
        if (transformed[key] && typeof transformed[key] === 'string') {
          if (key === 'id' && tableName === 'companies') {
            // Company IDs should remain as integers
            transformed[key] = parseInt(transformed[key]);
          } else if (key.includes('Id') && key !== 'id' && !key.includes('google') && !key.includes('auth')) {
            // Handle foreign key integer references
            if (key === 'companyId' || key === 'fromCompanyId') {
              transformed[key] = parseInt(transformed[key]);
            }
          }
        }

        // Handle numeric fields
        if (typeof transformed[key] === 'string' && !isNaN(transformed[key]) && transformed[key] !== '') {
          if (key.includes('Amount') || key.includes('Price') || key.includes('Rate') || 
              key.includes('Balance') || key.includes('Total') || key.includes('Percent') ||
              key === 'subtotal' || key === 'taxAmount' || key === 'totalAmount' ||
              key === 'quantity' || key === 'unitPrice' || key === 'total' ||
              key === 'amount' || key === 'cogs' || key === 'cogsPaid' ||
              key === 'cost' || key === 'price' || key === 'startingBalance' ||
              key === 'currentBalance' || key === 'ownershipPercent') {
            transformed[key] = parseFloat(transformed[key]);
          }
        }

        // Convert empty strings to null for optional fields
        if (transformed[key] === '') {
          transformed[key] = null;
        }
        
        // Handle missing required fields
        if (tableName === 'products' && key === 'description' && !transformed[key]) {
          transformed[key] = ''; // Products require description, set empty string as default
        }
      });

      // Handle special foreign key relationships for Prisma
      if (tableName === 'clients' && transformed.companyId) {
        const companyId = transformed.companyId;
        delete transformed.companyId;
        transformed.company = { connect: { id: companyId } };
      }
      
      if (tableName === 'vendors' && transformed.companyId) {
        const companyId = transformed.companyId;
        delete transformed.companyId;
        transformed.company = { connect: { id: companyId } };
      }
      
      if (tableName === 'products' && transformed.companyId) {
        const companyId = transformed.companyId;
        delete transformed.companyId;
        transformed.company = { connect: { id: companyId } };
      }
      
      if (tableName === 'bank_accounts' && transformed.companyId) {
        const companyId = transformed.companyId;
        delete transformed.companyId;
        transformed.company = { connect: { id: companyId } };
      }
      
      if (tableName === 'digital_wallets' && transformed.companyId) {
        const companyId = transformed.companyId;
        delete transformed.companyId;
        transformed.company = { connect: { id: companyId } };
      }
      
      if (tableName === 'invoices' && transformed.fromCompanyId) {
        const companyId = transformed.fromCompanyId;
        delete transformed.fromCompanyId;
        transformed.company = { connect: { id: companyId } };
      }
      
      if (tableName === 'bookkeeping_entries' && transformed.companyId) {
        const companyId = transformed.companyId;
        delete transformed.companyId;
        transformed.company = { connect: { id: companyId } };
      }
      
      if (tableName === 'chart_of_accounts' && transformed.companyId) {
        const companyId = transformed.companyId;
        delete transformed.companyId;
        transformed.company = { connect: { id: companyId } };
      }
      
      if (tableName === 'tax_treatments' && transformed.companyId) {
        const companyId = transformed.companyId;
        delete transformed.companyId;
        transformed.company = { connect: { id: companyId } };
      }

      return transformed;
    });
  }

  async importTable(tableName) {
    const modelName = TABLE_TO_MODEL_MAP[tableName];
    if (!modelName) {
      console.log(`‚ö†Ô∏è  No model mapping found for ${tableName}, skipping...`);
      return 0;
    }

    const data = this.loadTableData(tableName);
    if (!data || data.length === 0) {
      console.log(`‚ö†Ô∏è  No data to import for ${tableName}`);
      return 0;
    }

    try {
      const transformedData = this.transformDataForPostgreSQL(tableName, data);
      let imported = 0;
      let skipped = 0;

      console.log(`\nüì• Importing ${transformedData.length} records into ${tableName}...`);

      // Import records in batches to handle large datasets
      const batchSize = 100;
      for (let i = 0; i < transformedData.length; i += batchSize) {
        const batch = transformedData.slice(i, i + batchSize);
        
        for (const record of batch) {
          try {
            await this.prisma[modelName].create({
              data: record
            });
            imported++;
          } catch (error) {
            // Handle specific constraint violations
            if (error.code === 'P2002') {
              console.log(`   ‚ö†Ô∏è  Skipping duplicate record in ${tableName}:`, record.id || 'unknown');
              skipped++;
            } else {
              console.error(`   ‚ùå Error importing record in ${tableName}:`, error.message);
              this.errors.push({
                table: tableName,
                record,
                error: error.message
              });
            }
          }
        }

        // Progress indicator
        if (i + batchSize < transformedData.length) {
          console.log(`   üìä Progress: ${Math.min(i + batchSize, transformedData.length)}/${transformedData.length}`);
        }
      }

      this.importStats[tableName] = { imported, skipped, total: transformedData.length };
      console.log(`‚úÖ ${tableName}: ${imported} imported, ${skipped} skipped`);
      
      return imported;
    } catch (error) {
      console.error(`‚ùå Failed to import ${tableName}:`, error);
      this.errors.push({
        table: tableName,
        error: error.message
      });
      return 0;
    }
  }

  async importAllTables() {
    console.log('üöÄ Starting PostgreSQL data import...\n');
    
    let totalImported = 0;
    
    for (const tableName of TABLE_IMPORT_ORDER) {
      try {
        const imported = await this.importTable(tableName);
        totalImported += imported;
      } catch (error) {
        console.error(`Critical error importing ${tableName}:`, error);
        // Continue with other tables
      }
    }

    // Write import summary
    const summary = {
      importDate: new Date().toISOString(),
      totalImported,
      tableStats: this.importStats,
      errors: this.errors,
      importOrder: TABLE_IMPORT_ORDER
    };

    fs.writeFileSync(
      path.join(IMPORT_DIR, 'import-summary.json'),
      JSON.stringify(summary, null, 2)
    );

    console.log(`\nüéâ Import complete!`);
    console.log(`   üìä Total records imported: ${totalImported}`);
    console.log(`   ‚ö†Ô∏è  Total errors: ${this.errors.length}`);
    
    if (this.errors.length > 0) {
      console.log(`\n‚ùå Errors encountered during import:`);
      this.errors.slice(0, 5).forEach(error => {
        console.log(`   ‚Ä¢ ${error.table}: ${error.error}`);
      });
      if (this.errors.length > 5) {
        console.log(`   ‚Ä¢ ... and ${this.errors.length - 5} more errors`);
      }
      console.log(`\nFull error details saved to: ${path.join(IMPORT_DIR, 'import-summary.json')}`);
    }

    return summary;
  }

  async validateImport() {
    console.log('\nüîç Validating imported data...');
    
    const validationResults = {};
    
    for (const tableName of TABLE_IMPORT_ORDER) {
      const modelName = TABLE_TO_MODEL_MAP[tableName];
      if (!modelName) continue;

      try {
        const count = await this.prisma[modelName].count();
        validationResults[tableName] = count;
        console.log(`   ‚úÖ ${tableName}: ${count} records`);
      } catch (error) {
        console.log(`   ‚ùå ${tableName}: Error counting records - ${error.message}`);
        validationResults[tableName] = 'ERROR';
      }
    }

    return validationResults;
  }

  async close() {
    await this.prisma.$disconnect();
    console.log('PostgreSQL connection closed');
  }
}

// Run the import
async function runImport() {
  // Check if import directory exists
  if (!fs.existsSync(IMPORT_DIR)) {
    console.error(`Import directory not found: ${IMPORT_DIR}`);
    console.log('Please run the export script first to generate data files.');
    process.exit(1);
  }

  const importer = new PostgreSQLDataImporter();
  
  try {
    await importer.connect();
    await importer.importAllTables();
    await importer.validateImport();
  } catch (error) {
    console.error('Import failed:', error);
    process.exit(1);
  } finally {
    await importer.close();
  }
}

if (require.main === module) {
  runImport();
}

module.exports = { PostgreSQLDataImporter };